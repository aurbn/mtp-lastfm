# Copyright 2009 Daniel Woodhouse
#
#This file is part of mtp-lastfm.
#
#mtp-lastfm is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#mtp-lastfm is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with mtp-lastfm.  If not, see http://www.gnu.org/licenses/
import hashlib
import urllib2
import urllib
import webbrowser
import httplib
import xml.etree.ElementTree as ET
from httprequest import HttpRequest
import logger
log = logger.new_logger("webservices.py")

import localisation
_ = localisation.set_get_text()

class LastfmWebService(object):
    
    def __init__(self):
        self.api_key = "2d21a4ab6f049a413eb27dbf9af10579"
        self.api_2 = "6146d36f59da8720cd5f3dd2c8422da0"
        self.url = "http://ws.audioscrobbler.com/2.0/"
        log.debug("Web service variables: \napikey: %s\napi2: %s\nurl: %s\n" % (self.api_key, self.api_2, self.url))
    
    def request_session_token(self):
        """returns a token which is used authenticate mtp-lastfm with the users account"""
        data = {"api_key" : self.api_key, "method" : "auth.gettoken"}
        data['api_sig'] = self.create_api_sig(data)
        encoded_data = urllib.urlencode(data)
        url = self.url + "?" + encoded_data
        conn = urllib2.urlopen(url)
        return self.parse_xml(conn, "token")

    def parse_xml(self, conn, tag):
        """Searches an XML document for a single tag and returns its value"""
        tree = ET.parse(conn)
        iter = tree.getiterator()
        #list full tree for debugging
        for child in iter:
            log.debug(child.tag + " : " + child.text)
        for child in iter:
            if child.tag == tag:
                token = child.text
                break
        try:
            return token
        except:
            return False
        
    def parse_xml_doc(self, doc, tag):
        """Search an XML doc for tags and returns them all as a list"""
        tree = ET.parse(doc)
        iter = tree.getiterator()
        tags = []
        for child in iter:
            log.debug(child.tag + " : " + child.text)
            if child.tag == tag:
                tags.append(child.text)
        return tags
        
    def create_api_sig(self, dict):
        """dict is a dictionary of param_name : value sorted into the correct order"""
        data = ""
        items = dict.items()
        items.sort()
        for i in items:
            for j in i:
                data += j

        data += self.api_2
        api_sig = hashlib.md5(data.encode('UTF-8')).hexdigest()
        return api_sig
    
    
    def request_authorisation(self, token):
        """Opens a browser to request users authentication"""
        encoded_values = urllib.urlencode({
            "api_key" : self.api_key,
            "token" : token
        })
        log.debug("encoded values: %s" % str(encoded_values))
        print "Copy and paste this url into your browser:\nhttp://www.last.fm/api/auth/?%s" % encoded_values
        #webbrowser.open("http://www.last.fm/api/auth/?" + encoded_values)
        log.debug("webbrowser opened")
        
        
    def create_web_service_session(self, token):
        """The final step, this creates a token with infinite lifespan store in db"""
        data = {
            "api_key" : self.api_key,
            "method" : "auth.getsession",
            "token" : token }
        data['api_sig'] = self.create_api_sig(data)
        encode_values = urllib.urlencode(data)
        log.debug("Requesting infinite lifespan token")
        log.debug("encoded values: %s" % str(encode_values))
        url = self.url + "?" + encode_values
        try:
            conn = urllib2.urlopen(url)
            self.key = self.parse_xml(conn, "key")
            log.debug("Request successful")
            return True, self.key
        except urllib2.HTTPError:
            log.debug("Authentication problem")
            return False, _("A problem occurred during authentication")
    
    
    def love_track(self, artist, track, sk):
        #Params
        #track (Required) : A track name (utf8 encoded)
        #artist (Required) : An artist name (utf8 encoded)
        #api_key (Required) : A Last.fm API key.
        #api_sig (Required) : A Last.fm method signature.
        #sk (Required) : A session key generated by authenticating a user.
        post_values = {
            "track" : track,
            "artist" : artist,
            "api_key" : self.api_key,
            "method" : "track.love",
            "sk" : sk}
        post_values['api_sig'] = self.create_api_sig(post_values)
        post_values = urllib.urlencode(post_values)

        req = urllib2.Request(url=self.url, data=post_values)
        try:
            url_handle = urllib2.urlopen(req)
            response = url_handle.readlines()[1]
            l = response.find('"') + 1
            r = response.rfind('"')
            response = response[l:r]
            return response
        except urllib2.URLError, error:
            return error 
        except httplib.BadStatusLine, error:
            return error
        
    def get_user_top_tags(self, username, limit=15):
        #method user.getTopTags
        #Params
        #user (Required) : The user name
        #limit (Optional) : Limit the number of tags returned 
        #api_key (Required) : A Last.fm API key.
        encoded_values = urllib.urlencode(
            {"method" : "user.gettoptags",
             "user" : username,
             "limit" : limit,
             "api_key" : self.api_key}
            )
        url = self.url + "?" + encoded_values
        conn = HttpRequest(url) 
        xml_doc = conn.connect(xml=True)
        return self.parse_xml_doc(xml_doc, "name")
    
    def get_popular_tags(self, method, info_dict):
        """method is either artist.gettoptags or track.gettoptags"""
        #Params
        #track (Optional) : The track name in question
        #artist (Required) : The artist name in question
        #api_key (Required) : A Last.fm API key.
        dict = {"method" : method,
             "artist" : info_dict['Artist'],
             "api_key" : self.api_key}
        if method == "track.gettoptags":
            dict['track'] = info_dict['Track']
        encoded_values = urllib.urlencode(dict)
        url = self.url + "?" + encoded_values
        conn = HttpRequest(url) 
        xml_doc = conn.connect(xml=True)
        return self.parse_xml_doc(xml_doc, "name")
    
    
    def send_tags(self, method, info, tags, sk):
        """Sends tags to last.fm. method is one of:
        album.addtags, artist.addtags or track.addtags
        info_dict is the artist, track and album info
        tags is a comma delimited list of no more than 10 tags"""
        
        #All methods require these parameters:
        #tags (Required) : A comma delimited list of user supplied tags to apply
        #to this album. Accepts a maximum of 10 tags.
        #api_key (Required) : A Last.fm API key.
        #api_sig (Required)
        #sk (Required)
        #artist (Required) : The artist name in question

        post_values = {
            "method" : method,
            "tags" : tags,
            "api_key" : self.api_key,
            "sk" : sk,
            "artist" : info['Artist']}

        #these methods require additional info:
        #album.addTags -> album
        #track.addTags -> track
        if method == "album.addtags":
            post_values['album'] = info['Album']
        if method == "track.addtags":
            post_values['track'] = info['Track']
        post_values['api_sig'] = self.create_api_sig(post_values)
        conn = HttpRequest(self.url, urllib.urlencode(post_values))
        response = conn.connect()
 
